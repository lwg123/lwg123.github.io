<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="lwg的空间">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="lwg的空间">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lwg的空间">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>lwg的空间</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">lwg的空间</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/16/sqlite编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lwg123">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lwg的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/16/sqlite编程/" itemprop="url">ios的sqlite编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-16T10:03:14+08:00">
                2017-08-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-什么是SQLite？"><a href="#1-什么是SQLite？" class="headerlink" title="1.什么是SQLite？"></a>1.什么是SQLite？</h3><blockquote>
<p>SQLite是一款轻型的嵌入式数据库，它占用资源非常的低，在嵌入式设备中，可能只需要几百K的内存就够了， 它的处理速度比Mysql、PostgreSQL这两款著名的数据库都还快。</p>
</blockquote>
<h3 id="2-数据库存储数据的步骤"><a href="#2-数据库存储数据的步骤" class="headerlink" title="2.数据库存储数据的步骤"></a>2.数据库存储数据的步骤</h3><blockquote>
<p>1.新建数据库文件<br>2.新建一张表（table）<br>3.添加多个字段（column，列，属性）<br>4.添加多行记录（row，每行存放多个字段对应的值）</p>
</blockquote>
<h3 id="3-理论基础"><a href="#3-理论基础" class="headerlink" title="3.理论基础"></a>3.理论基础</h3><p>1.表格组成: 行(记录)和列(属性)  </p>
<blockquote>
<p>“属性” 是用来标识这一列应该存放什么<br>“记录” 是用来存放一条数据  </p>
</blockquote>
<p>2.属性类型</p>
<blockquote>
<p>blob 二进制类型<br>integer 整型<br>real浮点型<br>text文本类型<br>null 空</p>
</blockquote>
<p>3.主键</p>
<blockquote>
<p>主键（Primary Key，简称PK）用来唯一地标识某一条记录<br>主键可以是一个字段或多个字段<br>主键的设计原则:主键应当是对用户没有意义的,永远也不要更新主键,主键不应包含动态变化的数据,主键应当由计算机自动生成</p>
</blockquote>
<p>4.SQL中的常用关键字</p>
<blockquote>
<p>数据库中不可以使用关键字来命名表、字段<br>select、insert、update、delete、from、create、where、desc、order、by、group、table、alter、view、index等等</p>
</blockquote>
<p>5.SQL语句的种类</p>
<blockquote>
<p>数据定义语句（DDL：Data Definition Language）<br>包括create和drop, Alert等操作<br>在数据库中创建新表或删除表（create table或 drop table）</p>
<p>数据操作语句（DML：Data Manipulation Language）<br>   包括insert、delete、update等操作<br>   上面的3种操作分别用于添加、修改、删除表中的数据</p>
<p>数据查询语句（DQL：Data Query Language）<br>   可以用于查询获得表中的数据<br>   关键字select是DQL（也是所有SQL）用得最多的操作<br>   其他DQL常用的关键字有where，order by，group by和having</p>
</blockquote>
<p>6.补充资料 <a href="http://www.phpstudy.net/e/sql/sql_intro.html" target="_blank" rel="external">http://www.phpstudy.net/e/sql/sql_intro.html</a></p>
<h3 id="4-DDL语句"><a href="#4-DDL语句" class="headerlink" title="4.DDL语句"></a>4.DDL语句</h3><p>1.新建和打开数据库</p>
<blockquote>
<p>sqlite3_open(filePath, &amp;database);</p>
</blockquote>
<p>2.创建table</p>
<blockquote>
<p>create table 表名 (字段名1 字段类型1, 字段名2 字段类型2, …) ;<br>示例<br>create table if not exists t_student (id integer, name text, age inetger, score real) ;<br>说明：实际上SQLite是无类型的<br>    就算声明为integer类型，还是能存储字符串文本（主键除外）<br>    建表时声明啥类型或者不声明类型都可以，也就意味着创表语句可以这么写：<br>    create table t_student(name, age);<br>    为了保持良好的编程规范、方便程序员之间的交流，编写建表语句的时候最好加上每个字段的具体类型。</p>
</blockquote>
<p>3.删表  </p>
<blockquote>
<p>drop table if exists 表名 ;  </p>
</blockquote>
<p>4.修改表</p>
<blockquote>
<p>修改表名<br>ALTER TABLE 旧表名 RENAME TO 新表名<br>新增属性<br>   ALTER TABLE 表名 ADD COLUMN 列名 数据类型 限定符</p>
</blockquote>
<h3 id="5-给字段添加约束"><a href="#5-给字段添加约束" class="headerlink" title="5.给字段添加约束"></a>5.给字段添加约束</h3><blockquote>
<p>简单约束<br>  不能为空<br>   not null ：规定字段的值不能为null<br>  不能重复<br>   unique ：规定字段的值必须唯一<br>  默认值<br>   default ：指定字段的默认值<br>  示例<br>   create table t_student (id integer, name text not null unique, age integer not null default 1) ;<br>   name字段不能为null，并且唯一<br>   age字段不能为null，并且默认为1</p>
<p>主键约束<br>  添加主键约束的原因?<br>   如果t_student表中就name和age两个字段，而且有些记录的name和age字段的值都一样时，那么就没法区分这些数据，造成数据库的记录不唯一，这样就不方便管理数据<br>   良好的数据库编程规范应该要保证每条记录的唯一性，为此，增加了主键约束<br>   也就是说，每张表都必须有一个主键，用来标识记录的唯一性<br>   在创表的时候用primary key声明一个主键<br>   如果想要让主键自动增长（必须是integer类型），应该增加autoincrement</p>
</blockquote>
<pre><code>create table t_student (id integer primary key autoincrement, name text, age integer) ;
</code></pre><h3 id="6-DML语句"><a href="#6-DML语句" class="headerlink" title="6.DML语句"></a>6.DML语句</h3><p>1.插入数据（insert）</p>
<blockquote>
<p>格式<br>   insert into 表名 (字段1, 字段2, …) values (字段1的值, 字段2的值, …) ;<br>  示例<br>   insert into t_student (name, age) values (‘sz’, 10) ;<br>  注意<br>   数据库中的字符串内容应该用单引号 ’ 括住  </p>
</blockquote>
<p>2.更新数据（update）</p>
<blockquote>
<p>格式<br>   update 表名 set 字段1 = 字段1的值, 字段2 = 字段2的值, … ;<br>  示例<br>   update t_student set name = ‘wex’, age = 20 ;<br>  注意<br>   上面的示例会将t_student表中所有记录的name都改为wex，age都改为20</p>
</blockquote>
<p>3.删除数据（delete）</p>
<blockquote>
<p>格式<br>   delete from 表名 ;<br>  示例<br>   delete from t_student ;<br>  注意<br>   上面的示例会将t_student表中所有记录都删掉</p>
</blockquote>
<h3 id="7-条件语句"><a href="#7-条件语句" class="headerlink" title="7.条件语句"></a>7.条件语句</h3><p>作用:<br>  如果只想更新或者删除某些固定的记录，那就必须在DML语句后加上一些条件<br> 条件语句的常见格式</p>
<blockquote>
<p>where 字段 = 某个值 ; // 不能用两个 =<br>  where 字段 is 某个值 ; // is 相当于 =<br>  where 字段 != 某个值 ;<br>  where 字段 is not 某个值 ; // is not 相当于 !=<br>  where 字段 &gt; 某个值 ;<br>  where 字段1 = 某个值 and 字段2 &gt; 某个值 ; // and相当于C语言中的 &amp;&amp;<br>  where 字段1 = 某个值 or 字段2 = 某个值 ; // or 相当于C语言中的 ||<br>  示例：<br>  将t_student表中年龄大于10 并且 姓名不等于wex的记录，年龄都改为 5<br>update t_student set age = 5 where age &gt; 10 and name != ‘wex’ ;<br>   删除t_student表中年龄小于等于10 或者 年龄大于30的记录<br>delete from t_student where age &lt;= 10 or age &gt; 30 ;</p>
</blockquote>
<h3 id="8-DQL语句"><a href="#8-DQL语句" class="headerlink" title="8.DQL语句"></a>8.DQL语句</h3><blockquote>
<p>格式<br>  select 字段1, 字段2, … from 表名 ;<br>  select <em> from 表名; // 查询所有的字段<br> 示例<br>  select name, age from t_student ;<br>  select </em> from t_student ;<br>  select * from t_student where age &gt; 10 ; // 条件查询</p>
</blockquote>
<h3 id="9-代码实现DML语句-Insert绑定参数"><a href="#9-代码实现DML语句-Insert绑定参数" class="headerlink" title="9.代码实现DML语句-Insert绑定参数"></a>9.代码实现DML语句-Insert绑定参数</h3><blockquote>
<p>准备语句（prepared statement）对象代表一个简单SQL语句对象的实例，这个对象通常被称为“准备语句”或者“编译好的SQL语句”或者就直接称为“语句”。</p>
<p>操作历程  </p>
<ol>
<li>使用sqlite3_prepare_v2或相关的函数创建这个对象<br>如果执行成功，则返回SQLITE_OK，否则返回一个错误码  <ol>
<li>使用sqlite3<em>bind</em>*()给宿主参数（host parameters）绑定值<br>sqlite3_bind_text<br>参数1: 准备语句<br>参数2:绑定的参数索引 (从1开始)<br>参数3:绑定的参数内容<br>参数4:绑定的参数长度 (-1代表自动计算长度)<br>参数5:参数的处理方式<br>SQLITE_TRANSIENT 会对字符串做一个 copy，SQLite 选择合适的机会释放<br>SQLITE_STATIC / nil 把它当做全局静态变量, 不会字符串做任何处理，如果字符串被释放，保存到数据库的内容可能不正确！  <ol>
<li>通过调用sqlite3_step() 一次或多次来执行这个sql<br>对于DML语句, 如果执行成功, 返回SQLITE_DONE<br>对于DQL语句, 通过多次执行获取结果集, 继续执行的条件是返回值 SQLITE_ROW  </li>
</ol>
</li>
<li>使用sqlite3_reset()重置这个语句，然后回到第2步，这个过程做0次或多次  </li>
</ol>
</li>
<li>使用sqlite3_finalize()销毁这个对象, 防止内存泄露</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">const char *insertSQL = &quot;insert into word_inf values(null,?,?)&quot;;</div><div class="line">sqlite3_stmt *stmt;</div><div class="line">//预编译SQL语句，stmt变量保存了预编译结果的指针</div><div class="line"> int insertReasult = sqlite3_prepare_v2(database, insertSQL, -1, &amp;stmt, NULL);</div><div class="line"> //如果预编译成功</div><div class="line"> if (insertReasult == SQLITE_OK) &#123;</div><div class="line">     // 为第一个？占位符绑定参数</div><div class="line">   sqlite3_bind_text(stmt, 1, [word UTF8String], -1, NULL);</div><div class="line">   // 为第二个？占位符绑定参数</div><div class="line">   sqlite3_bind_text(stmt, 2, [detail UTF8String], -1, NULL);</div><div class="line">   // 执行SQL语句</div><div class="line">    sqlite3_step(stmt);</div><div class="line">  &#125;</div><div class="line">sqlite3_finalize(stmt);</div></pre></td></tr></table></figure>
<h3 id="10-代码实现DQL语句"><a href="#10-代码实现DQL语句" class="headerlink" title="10.代码实现DQL语句"></a>10.代码实现DQL语句</h3><p>实现查询到的数据转化为OC对象，并存储在数组中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> sqlite3 *database;</div><div class="line"> sqlite3_open([[self dbPath] UTF8String], &amp;database);</div><div class="line">const char *selectSQL = &quot;select * from word_inf where word like ?&quot;;</div><div class="line">sqlite3_stmt *stmt;</div><div class="line">        </div><div class="line">int queryReasult = sqlite3_prepare_v2(database, selectSQL, -1, &amp;stmt, NULL);</div><div class="line">NSMutableArray *result = [NSMutableArray array];</div><div class="line">if (queryReasult == SQLITE_OK) &#123;</div><div class="line">     // 为第一个？占位符绑定参数</div><div class="line">    sqlite3_bind_text(stmt, 1, [[NSString stringWithFormat:@&quot;%%%@%%&quot;,key] UTF8String], -1, NULL);</div><div class="line">// 采用循环多次执行sqlite3_step()函数，并从中取出查询结果</div><div class="line">   while (sqlite3_step(stmt) == SQLITE_ROW) &#123;</div><div class="line">    // 分别获取当前行的不同列的查询数据</div><div class="line">    int word_id = sqlite3_column_int(stmt, 0);</div><div class="line">    char *word = (char *)sqlite3_column_text(stmt, 1);</div><div class="line">  char *detail = (char *)sqlite3_column_text(stmt, 2);</div><div class="line">  FKWord *fkWord = [[FKWord alloc] initWithId:word_id word:[NSString stringWithUTF8String:word] detail:[NSString stringWithUTF8String:detail]];</div><div class="line">   [result addObject:fkWord];</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="11-代码实现-事务"><a href="#11-代码实现-事务" class="headerlink" title="11.代码实现-事务"></a>11.代码实现-事务</h3><blockquote>
<p>概念</p>
</blockquote>
<p>  事务（Transaction）是并发控制的单位，是用户定义的一个操作序列。这些操作要么都做，要么都不做，是一个不可分割的工作单位。通过事务，可以将逻辑相关的一组操作绑定在一起，保持数据的完整性。</p>
<p>  事务通常是以BEGIN TRANSACTION开始，以COMMIT TRANSACTION或ROLLBACK TRANSACTION结束。</p>
<p>   COMMIT表示提交，即提交事务的所有操作。具体地说就是将事务中所有对数据库的更新写回到磁盘上的物理数据库中去，事务正常结束。</p>
<p>   ROLLBACK表示回滚，即在事务运行的过程中发生了某种故障，事务不能继续进行，系统将事务中对数据库的所有已完成的操作全部撤消，滚回到事务开始的状态。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">修改两条记录, 一个成功, 一个失败测试</div><div class="line"></div><div class="line">   XMGSQLTool.shareInstance.beginTransaction()</div><div class="line"></div><div class="line">   let result1 = Student.updateStudent(&quot;score = score - 10&quot;, condition: &quot;name = &apos;zs&apos;&quot;)</div><div class="line"></div><div class="line">   let result2 = Student.updateStudent(&quot;score1 = score + 10&quot;, condition: &quot;name = &apos;wex&apos;&quot;)</div><div class="line"></div><div class="line">   // 如果都执行成功再提交, 如果都不成功, 那就回滚</div><div class="line">if result1 &amp;&amp; result2</div><div class="line"> &#123;</div><div class="line">    XMGSQLTool.shareInstance.commitTransaction()</div><div class="line"> &#125;else</div><div class="line"> &#123;</div><div class="line">  XMGSQLTool.shareInstance.rollBackTransaction()</div><div class="line"> &#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/14/ios数据存储/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lwg123">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lwg的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/14/ios数据存储/" itemprop="url">iOS数据存储方法(归档)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-14T09:35:44+08:00">
                2017-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1、对象归档"><a href="#1、对象归档" class="headerlink" title="1、对象归档"></a>1、对象归档</h3><p><code>所谓对象归档，类似于“序列化”机制，归档就是用某种格式把一个或多  
个对象保存到指定文件中，方便以后从文件中恢复他们。</code></p>
<h4 id="1-1-使用NSKeyedArchiver归档"><a href="#1-1-使用NSKeyedArchiver归档" class="headerlink" title="1.1 使用NSKeyedArchiver归档"></a>1.1 使用NSKeyedArchiver归档</h4><p>NSKeyedArchiver和NSKeyedUnarchiver      </p>
<h4 id="对系统类型直接归档"><a href="#对系统类型直接归档" class="headerlink" title="对系统类型直接归档"></a>对系统类型直接归档</h4><p>archiveRootObject: toFile:<br>unarchiveObjectWithFile:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//对象归档</div><div class="line">- (void)test5&#123;</div><div class="line">    //第一种方法，直接调用NSKeyedArchiver</div><div class="line">    //先创建一个NSDictionary对象</div><div class="line">    NSDictionary *dict = @&#123;</div><div class="line">                           @&quot;Objective-C&quot; : @89,</div><div class="line">                           @&quot;Rubby&quot; : @69,</div><div class="line">                           @&quot;Python&quot; : @75,</div><div class="line">                           @&quot;Perl&quot; : @109</div><div class="line">                           &#125;;</div><div class="line">    // 对dict对象进行归档</div><div class="line">    NSString *filePath = @&quot;/Users/lwg/Desktop/SettingBundle/SettingBundle/dict.archive&quot;;</div><div class="line">    [NSKeyedArchiver archiveRootObject:dict toFile:filePath];</div><div class="line">    </div><div class="line">    // 读取dict.archive</div><div class="line">    NSDictionary *dict1 = [NSKeyedUnarchiver unarchiveObjectWithFile:filePath];</div><div class="line">    NSLog(@&quot;%@&quot;,dict1);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="1-2-实现NSCoding协议"><a href="#1-2-实现NSCoding协议" class="headerlink" title="1.2 实现NSCoding协议"></a>1.2 实现NSCoding协议</h3><p>一般来说，如果对象的实例变量是OC基本类型，并且实现了NSCoding协议，则可直接调用encodingObject:forKey:方法来归档该实例变量，使用decodeObjectForKey:方法恢复该实例变量即可。<br>如果需要归档、恢复任意自定义类的实例，那么该类型应该实现NSCoding协议如下两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">initWithCoder:</div><div class="line">encodeWithCoder:</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">@interface FKApple : NSObject&lt;NSCoding&gt;</div><div class="line"></div><div class="line">@property (nonatomic,copy) NSString *color;</div><div class="line">@property (nonatomic,assign) double weight;</div><div class="line">@property (nonatomic,assign) int size;</div><div class="line">- (id)initWithColor:(NSString *)color weight:(double)weight size:(int)size;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">方法实现</div><div class="line">- (void)encodeWithCoder:(NSCoder *)aCoder&#123;</div><div class="line">    //调用NSCoder的方法归档该对象的每个实例变量</div><div class="line">    [aCoder encodeObject:_color forKey:@&quot;color&quot;];</div><div class="line">    [aCoder encodeDouble:_weight forKey:@&quot;weight&quot;];</div><div class="line">    [aCoder encodeInt:_size forKey:@&quot;size&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder&#123;</div><div class="line">    // 使用NSCoder恢复color、weight、size这3个key</div><div class="line">    // 所对应的value，并将恢复的value赋给当前对象的3个实例变量</div><div class="line">    _color = [aDecoder decodeObjectForKey:@&quot;color&quot;];</div><div class="line">    _weight = [aDecoder decodeDoubleForKey:@&quot;weight&quot;];</div><div class="line">    _size = [aDecoder decodeIntForKey:@&quot;size&quot;];</div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="1-3使用NSData完成自定义归档"><a href="#1-3使用NSData完成自定义归档" class="headerlink" title="1.3使用NSData完成自定义归档"></a>1.3使用NSData完成自定义归档</h3><p>上面的方法每次只能将单个对象作为root进行归档或者恢复，如果希望一次性收集多个对象，并进行归档到单个文件中，可以使用NSMutableData来创建NSKeyedArchiver和NSKeyedUnarchiver对象。<br>步骤如下：<br>1.以NSMutableData作为参数，创建NSKeyedArchiver对象；<br>2.重复调用NSKeyedArchiver对象的encodeObject：forKey：方法来归档所有需要归档到一个文件中的对象。<br>3.调用NSKeyedArchiver对象的finishEncoding方法结束归档；<br>4.根据需要，程序可以选择将保存归档数据的NSData通过网络传输或者输出到磁盘文件上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">// 使用NSData完成自定义归档</div><div class="line">// 一次性将多个对象归档到单个文件中</div><div class="line">- (void)test6&#123;</div><div class="line">    //先创建一个NSDictionary对象</div><div class="line">    NSDictionary *dict = @&#123;</div><div class="line">                           @&quot;Objective-C&quot; : @89,</div><div class="line">                           @&quot;Rubby&quot; : @69,</div><div class="line">                           @&quot;Python&quot; : @75,</div><div class="line">                           @&quot;Perl&quot; : @109</div><div class="line">                           &#125;;</div><div class="line">    // 创建一个NSSet对象</div><div class="line">    NSSet *set = [NSSet setWithObjects:@&quot;ios&quot;,@&quot;Java&quot;,@&quot;OC&quot;, nil];</div><div class="line">    FKApple *apple = [[FKApple alloc] initWithColor:@&quot;红色&quot; weight:3.4 size:20];</div><div class="line">    // 创建一个NSMutableData对象，用于保存归档数据</div><div class="line">    NSMutableData *data = [NSMutableData data];</div><div class="line">    NSKeyedArchiver *arch = [[NSKeyedArchiver alloc] initForWritingWithMutableData:data];</div><div class="line">    </div><div class="line">    // 重复调用此方法</div><div class="line">    [arch encodeObject:dict forKey:@&quot;dict&quot;];</div><div class="line">    [arch encodeObject:set forKey:@&quot;set&quot;];</div><div class="line">    [arch encodeObject:apple forKey:@&quot;apple&quot;];</div><div class="line">    </div><div class="line">    [arch finishEncoding];</div><div class="line">    </div><div class="line">    // 程序将NSData缓存区保存的数据写入文件</div><div class="line">     NSString *filePath = @&quot;/Users/lwg/Desktop/SettingBundle/SettingBundle/multi.archive&quot;;</div><div class="line">    if ([data writeToFile:filePath atomically:YES] == NO) &#123;</div><div class="line">        NSLog(@&quot;归档失败！&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 读取归档</div><div class="line">    NSData *data1 = [NSData dataWithContentsOfFile:filePath];</div><div class="line">    NSKeyedUnarchiver *unarch = [[NSKeyedUnarchiver alloc] initForReadingWithData:data1];</div><div class="line">    NSDictionary *dict1 = [unarch decodeObjectForKey:@&quot;dict&quot;];</div><div class="line">    NSSet *set1 = [unarch decodeObjectForKey:@&quot;set&quot;];</div><div class="line">    FKApple *apple1 = [unarch decodeObjectForKey:@&quot;apple&quot;];</div><div class="line">    [unarch finishDecoding];</div><div class="line">    NSLog(@&quot;%@&quot;,dict1);</div><div class="line">    NSLog(@&quot;%@&quot;,set1);</div><div class="line">    NSLog(@&quot;%@&quot;,apple1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="1-4使用归档实现深复制"><a href="#1-4使用归档实现深复制" class="headerlink" title="1.4使用归档实现深复制"></a>1.4使用归档实现深复制</h3><p>当程序归档一个对象时，系统会把该对象关联的所有数据都转化为字节数据；如果程序从这些字节数据中恢复该对象，恢复出来的对象与原对象完全相同，但没有任何公用的部分，这就实现了深复制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// 利用归档实现深复制</div><div class="line">- (void)deepCopy&#123;</div><div class="line">    NSDictionary *dict = @&#123;</div><div class="line">                           @&quot;one&quot; : [[FKApple alloc] initWithColor:@&quot;红色&quot; weight:3.4 size:20],</div><div class="line">                           @&quot;two&quot; : [[FKApple alloc] initWithColor:@&quot;绿色&quot; weight:2.8 size:14]</div><div class="line">                           &#125;;</div><div class="line">    // 将归档对象的数据写入NSData</div><div class="line">    NSData *data = [NSKeyedArchiver archivedDataWithRootObject:dict];</div><div class="line">    // 从NSData对象中恢复对象，这样既可完成深复制</div><div class="line">    NSDictionary *dictCopy = [NSKeyedUnarchiver unarchiveObjectWithData:data];</div><div class="line">    // 获取复制后的对象</div><div class="line">    FKApple *app = [dictCopy objectForKey:@&quot;one&quot;];</div><div class="line">    // 修改对象属性</div><div class="line">    [app setColor:@&quot;紫色&quot;];</div><div class="line">    </div><div class="line">    // 获取原始对象</div><div class="line">    FKApple *oneApp = [dict objectForKey:@&quot;one&quot;];</div><div class="line">    // 访问该对象颜色，发现并没有改变</div><div class="line">    NSLog(@&quot;dict中key为one对应的颜色为:%@,复制后的app颜色为:%@&quot;,oneApp.color,app.color);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/14/Socket通信/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lwg123">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lwg的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/14/Socket通信/" itemprop="url">Socket理解和使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-14T21:17:51+08:00">
                2017-07-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1、TCP-IP"><a href="#1、TCP-IP" class="headerlink" title="1、TCP/IP"></a>1、TCP/IP</h3><p>TCP/IP就是传输控制协议/网间协议，网络层的“ip地址”可以唯一标识网络中的主机，而传输层的“协议+端口”可以唯一标识主机中的应用程序（进程）<br>下面说一下IP地址和端口号</p>
<h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p>IP地址用于唯一标识网络中的一个通信实体，这个通信实体既可以是一台主机，也可以是一台打印机，或者是路由器的某一个端口。在基于IP协议的网络中传输的数据包，都必须使用IP地址在进行标识。IP地址用于唯一标识网络上的一个通信实体，但一个通信实体可以有多个通信程序同时提供网络服务，此时还需要使用端口。</p>
<h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><p>端口是一个16位的整数，用于表示数据交给哪个通信程序处理。一次端口就是应用程序与外界交流的出入口，它是一种抽象的软件结构，包括一些数据结构I/O(基本输入输出)缓冲区。不同的应用程序处理不同端口上的数据，同一台机器上不能有两个程序使用同一个端口，端口号从0到65535。<br>TCP/IP协议参考模型把所有的TCP/IP系列协议归类到四个抽象层中，<br>应用层：TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等<br>传输层：TCP，UDP<br>网络层：IP，ICMP，OSPF，EIGRP，IGMP<br>数据链路层：SLIP，CSLIP，PPP，MTU<br><img src="http://oqfs0y2cu.bkt.clouddn.com/17-7-14/40970466.jpg" alt=""></p>
<h3 id="2、Socket"><a href="#2、Socket" class="headerlink" title="2、Socket"></a>2、Socket</h3><p>利用ip地址＋协议＋端口号唯一标示网络中的一个进程，就可以利用socket进行通信了，我们经常把socket翻译为套接字，socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用以实现进程在网络中通信。<br><img src="http://oqfs0y2cu.bkt.clouddn.com/17-7-14/31112059.jpg" alt=""></p>
<h4 id="socket通信流程"><a href="#socket通信流程" class="headerlink" title="socket通信流程"></a>socket通信流程</h4><p>socket是”打开—读/写—关闭”模式的实现，以使用TCP协议通讯的socket为例，其交互流程大概是这样子的<br><img src="http://oqfs0y2cu.bkt.clouddn.com/17-7-14/85317428.jpg" alt=""></p>
<h4 id="socket编程API"><a href="#socket编程API" class="headerlink" title="socket编程API"></a>socket编程API</h4><p>这里简单解释一下方法作用和参数 </p>
<pre><code>int socket(int domain, int type, int protocol);
</code></pre><p>根据指定的地址族、数据类型和协议来分配一个socket的描述字及其所用的资源。<br>domain:协议族，常用的有AF_INET、AF_INET6、AF_LOCAL、AF_ROUTE其中AF_INET代表使用ipv4地址。<br>type:socket类型，常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等<br>protocol:协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等 </p>
<pre><code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
</code></pre><p>把一个地址族中的特定地址赋给socket<br>sockfd:socket描述字，也就是socket引用<br>addr:要绑定给sockfd的协议地址<br>addrlen:地址的长度</p>
<pre><code>int listen(int sockfd, int backlog);
</code></pre><p>监听socket<br>sockfd:要监听的socket描述字<br>backlog:相应socket可以排队的最大连接个数 </p>
<pre><code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);    
</code></pre><p>连接某个socket<br>sockfd:客户端的socket描述字<br>addr:服务器的socket地址<br>addrlen:socket地址的长度</p>
<pre><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
</code></pre><p>TCP服务器监听到客户端请求之后，调用accept()函数取接收请求<br>sockfd:服务器的socket描述字<br>addr:客户端的socket地址<br>addrlen:socket地址的长度  </p>
<pre><code>ssize_t read(int fd, void *buf, size_t count);
</code></pre><p>读取socket内容<br>fd:socket描述字<br>buf：缓冲区<br>count：缓冲区长度</p>
<pre><code>ssize_t write(int fd, const void *buf, size_t count);
</code></pre><p>向socket写入内容，其实就是发送内容<br>fd:socket描述字<br>buf：缓冲区<br>count：缓冲区长度</p>
<pre><code>int close(int fd);
</code></pre><p>socket标记为以关闭 ，使相应socket描述字的引用计数-1，当引用计数为0的时候，触发TCP客户端向服务器发送终止连接请求。</p>
<p>###3、使用CFSocket实现TCP客户端<br>创建Socket</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">// 创建Socket，无需回调函数函数</div><div class="line">	_socket = CFSocketCreate(kCFAllocatorDefault</div><div class="line">		, PF_INET // 指定协议族，如果该参数为0或者负数，则默认为PF_INET</div><div class="line">		, SOCK_STREAM // 如果协议族为PF_INET,默认为SOCK_STREAM</div><div class="line">		, IPPROTO_TCP // 指定通信协议。如果前一个参数为SOCK_STREAM，默认使用TCP协议</div><div class="line">		, kCFSocketNoCallBack // 该参数指定下一个回调函数所监听的事件类型</div><div class="line">		, nil</div><div class="line">		, NULL);</div><div class="line">	if (_socket != nil)</div><div class="line">	&#123;</div><div class="line">		// 定义sockaddr_in类型的变量，该变量将作为CFSocket的地址</div><div class="line">		struct sockaddr_in addr4;</div><div class="line">		memset(&amp;addr4, 0, sizeof(addr4));</div><div class="line">		addr4.sin_len = sizeof(addr4);</div><div class="line">		addr4.sin_family = AF_INET;</div><div class="line">		// 设置连接远程服务器的地址,此处设置的位本机地址</div><div class="line">		addr4.sin_addr.s_addr = inet_addr(&quot;10.9.39.111&quot;);</div><div class="line">		// 设置连接远程服务器的监听端口</div><div class="line">		addr4.sin_port = htons(30000);</div><div class="line">		// 将IPv4的地址转换为CFDataRef</div><div class="line">		CFDataRef address = CFDataCreate(kCFAllocatorDefault</div><div class="line">			, (UInt8 *)&amp;addr4, sizeof(addr4));</div><div class="line">		// 连接远程服务器器的Socket，并返回连接的结果</div><div class="line">		CFSocketError result = CFSocketConnectToAddress(_socket</div><div class="line">			, address // 指定远程服务器的IP和端口</div><div class="line">			, 5  // 指定连接超时时长，如果该参数为负数，则把连接操作放在后台进行，</div><div class="line">			// 当_socket消息类型为kCFSocketConnectCallBack，</div><div class="line">			// 将会在连接成功或失败的时候在后台触发回调函数</div><div class="line">			);</div><div class="line">		// 如果连接远程服务器成功</div><div class="line">		if(result == kCFSocketSuccess)</div><div class="line">		&#123;</div><div class="line">			isOnline = YES;</div><div class="line">			// 启动新线程来读取服务器响应的数据</div><div class="line">			[NSThread detachNewThreadSelector:@selector(readStream)</div><div class="line">									 toTarget:self withObject:nil];</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>读取接收的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (void)readStream</div><div class="line">&#123;</div><div class="line">	char buffer[2048];</div><div class="line">	long hasRead;</div><div class="line">	//与本机关联的Socket 如果已经失效返回－1:INVALID_SOCKET</div><div class="line">	while ((hasRead = recv(CFSocketGetNative(_socket)</div><div class="line">		, buffer, sizeof(buffer), 0)))</div><div class="line">	&#123;</div><div class="line">		NSString* content = [[NSString alloc] initWithBytes:buffer</div><div class="line">			length:hasRead encoding:NSUTF8StringEncoding];</div><div class="line">		// 使用主线程来更新UI控件的状态</div><div class="line">		dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">			self.showView.text = [NSString stringWithFormat:@&quot;%@\n%@&quot;,</div><div class="line">				content ,self.showView.text];</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//发送数据</div><div class="line">const char* data = [messageTosend UTF8String];</div><div class="line">send(CFSocketGetNative(_socket), data, strlen(data) + 1 , 1);</div></pre></td></tr></table></figure>
<p>注<br>ios 服务器端文件编译：<br>先进入目标文件夹下<br>执行终端命令如下：<br>$ clang -fobjc-arc -framework Foundation SimpleServer.m<br>则会生成一个a.out 文件，然后运行a.out即可<br>a.out 文件的运行方式<br>$ chmod +x a.out<br>$ ./a.out<br><img src="http://oqfs0y2cu.bkt.clouddn.com/17-7-15/79800101.jpg" alt=""><br>出现上面所示则代表服务器绑定成功 </p>
<p><img src="http://oqfs0y2cu.bkt.clouddn.com/17-7-15/49828972.jpg" alt=""><br>然后运行客户端输入聊天信息即可收到，如图所示</p>
<p>详细代码和服务器端代码（SimpleServer.m）下载 <a href="https://github.com/lwg123/Socket_demo" target="_blank" rel="external">详细demo下载</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/01/KVC深入学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lwg123">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lwg的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/01/KVC深入学习/" itemprop="url">KVC解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-01T22:51:07+08:00">
                2017-07-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>valueForKey (总体规划，先找相关方法，再找相关变量)</p>
<ul>
<li>1、先是找相关方法，如果方法找不到</li>
<li><p>2、那么去判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)accessInstanceVariablesDirectly&#123;   </div><div class="line">   	return YES;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>此方法是否返回YES，默认为YES  </p>
</li>
<li><p>3、如果是NO，直接执行KVC的valueForUndefinedKey:(系统弹出异常，未定义key)，  </p>
<ul>
<li>如果是YES，继续再去找相关变量</li>
<li><p>相关方法：<strong>getKey</strong>, <strong>key</strong> 优先级getKey大<br>于变量方法：可以返回数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (NSUInteger)countOf&lt;Key&gt;&#123;</div><div class="line">     return 2;</div><div class="line">&#125;</div><div class="line">- (id)objectIn&lt;Key&gt;AtIndex:(NSUInteger)index&#123;</div><div class="line">   if (index == 0) &#123;</div><div class="line">       return @&quot;hanck&quot;; </div><div class="line">      &#125;</div><div class="line">   return @&quot;badian&quot;;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<pre><code>* 相关变量 **_key** **_isKey** **key** **isKey** 优先级依次降低
</code></pre><ul>
<li><p>setValue 方法</p>
<ul>
<li><p>先找set方法，找不到再给属性赋值 setKey setIsKey</p>
</li>
<li><p>setValue:(id)value forKeyPath:(NSString *)keyPath来设置私有变量</p>
</li>
<li>打断点在viewdidappear里获取subViews</li>
<li>隐藏方法：max min sum count avage</li>
</ul>
</li>
</ul>
<h3 id="KVO使用"><a href="#KVO使用" class="headerlink" title="KVO使用"></a>KVO使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context;</div><div class="line"></div><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123;</div><div class="line">    NSLog(@&quot;%@&quot;,change);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以手动触发通知，默认是自动触发通知</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/30/发票查询总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lwg123">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lwg的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/30/发票查询总结/" itemprop="url">发票查询小结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-30T21:21:11+08:00">
                2017-06-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="自定义searchBar"><a href="#自定义searchBar" class="headerlink" title="自定义searchBar"></a>自定义searchBar</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">- (UISearchBar *)searchBar &#123;</div><div class="line">    if (!_searchBar) &#123;</div><div class="line">        _searchBar = [[UISearchBar alloc] initWithFrame:CGRectMake(15, 77, SCREEN_WIDTH - 30, 30)];</div><div class="line">        _searchBar.backgroundImage = [[UIImage alloc] init];</div><div class="line">        _searchBar.barTintColor = [UIColor whiteColor];</div><div class="line">        _searchBar.delegate = self;</div><div class="line">        </div><div class="line">        UITextField *searchField = [_searchBar valueForKey:@&quot;_searchField&quot;];</div><div class="line">        if (searchField) &#123;</div><div class="line">            searchField.layer.cornerRadius = 5;</div><div class="line">            searchField.layer.borderWidth = 1;</div><div class="line">            searchField.layer.borderColor = RGB(205, 205, 205).CGColor;</div><div class="line">            searchField.layer.masksToBounds = YES;</div><div class="line"></div><div class="line">	// 隐藏左边的放大镜，自己定义自己的图片</div><div class="line">    [searchField setLeftViewMode:UITextFieldViewModeNever];</div><div class="line">            </div><div class="line">  &#125;</div><div class="line">        //自定义placeholder text</div><div class="line">        UILabel *label = [UILabel new];</div><div class="line">        label.frame = CGRectMake(50, 0, 180, 28);</div><div class="line">        label.text = @&quot;请输入关键字&quot;;</div><div class="line">        label.font = [UIFont systemFontOfSize:14];</div><div class="line">        label.textColor = RGB(0x99, 0x99, 0x99);</div><div class="line">        [_searchBar addSubview:label];</div><div class="line">        self.placeholderLable = label;</div><div class="line">        </div><div class="line">    UIImage *image = [UIImage imageNamed: @&quot;sousuo&quot;];</div><div class="line">    UIImageView *iView = [[UIImageView alloc] initWithImage:image];</div><div class="line">    iView.frame = CGRectMake(20, 6, image.size.width , image.size.height);</div><div class="line">    [_searchBar addSubview:iView];</div><div class="line">  </div><div class="line">  // 设置光标的位置从哪里开始显示</div><div class="line"> _searchBar.searchTextPositionAdjustment = UIOffsetMake(33, 0);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    return _searchBar;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="搜索关键字高亮显示"><a href="#搜索关键字高亮显示" class="headerlink" title="搜索关键字高亮显示"></a>搜索关键字高亮显示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 关键字高亮显示</div><div class="line">//先获取关键字的range</div><div class="line">   NSRange range = [companyName rangeOfString:_searchBar.text];</div><div class="line">   NSMutableAttributedString *attributeString = [[NSMutableAttributedString alloc] initWithString:companyName];</div><div class="line">    </div><div class="line">//设置标签文字属性</div><div class="line"> [attributeString setAttributes:@&#123;NSForegroundColorAttributeName : [UIColor redColor]&#125; range:range];</div><div class="line"> cell.lab.attributedText = attributeString;</div></pre></td></tr></table></figure>
<h3 id="文字下面加线"><a href="#文字下面加线" class="headerlink" title="文字下面加线"></a>文字下面加线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">UIButton *registerBtn = [UIButton buttonWithType:UIButtonTypeCustom];</div><div class="line">   registerBtn.frame = CGRectMake(0, _loginButton.frame.origin.y + _loginButton.frame.size.height + 10 * FitHeight, self.view.frame.size.width, 40 * FitHeight);</div><div class="line">   [registerBtn addTarget:self action:@selector(registerAction) forControlEvents:UIControlEventTouchUpInside];</div><div class="line">   [self.view addSubview:registerBtn];</div><div class="line">   NSMutableAttributedString *content = [[NSMutableAttributedString alloc]initWithString:[NSString stringWithFormat:@&quot;新用户注册&quot;]];</div><div class="line">   NSRange contentRange = &#123;0,[content length]&#125;;</div><div class="line">   [content addAttribute:NSUnderlineStyleAttributeName value:[NSNumber numberWithInteger:NSUnderlineStyleSingle] range:contentRange];</div><div class="line">   [content addAttribute:NSForegroundColorAttributeName value:[UIColor colorWithRed:0.57 green:0.38 blue:0.22 alpha:1.00] range:contentRange];</div><div class="line">   [registerBtn setAttributedTitle:content forState:UIControlStateNormal];</div></pre></td></tr></table></figure>
<h3 id="通过网页加载二维码"><a href="#通过网页加载二维码" class="headerlink" title="通过网页加载二维码"></a>通过网页加载二维码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">http://qr.topscan.com/api.php?text=</div><div class="line">此地址后面添加需要二维码显示的东西，即可在网上生成二维码</div><div class="line">直接加载此网页即可</div></pre></td></tr></table></figure>
<h3 id="网页图片调整到合适大小"><a href="#网页图片调整到合适大小" class="headerlink" title="网页图片调整到合适大小"></a>网页图片调整到合适大小</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 网页图片调整</div><div class="line">    NSString *js = @&quot;function imgAutoFit() &#123; \</div><div class="line">    var imgs = document.getElementsByTagName(&apos;img&apos;); \</div><div class="line">    // 此处如果图片较多采用循环方式改变每个图片的大小</div><div class="line">    imgs[0].style.maxWidth = 200;\</div><div class="line">    &#125;&quot;;</div><div class="line">    </div><div class="line">    [webView stringByEvaluatingJavaScriptFromString:js];</div><div class="line">    [webView stringByEvaluatingJavaScriptFromString:@&quot;imgAutoFit()&quot;];</div></pre></td></tr></table></figure>
<h3 id="监听键盘改变"><a href="#监听键盘改变" class="headerlink" title="监听键盘改变"></a>监听键盘改变</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (void)keyboardChange:(NSNotification *)note &#123;</div><div class="line">    NSDictionary *dict = note.userInfo;</div><div class="line">    CGRect endframe = [dict[UIKeyboardFrameEndUserInfoKey] CGRectValue];</div><div class="line">    CGFloat y = endframe.origin.y;</div><div class="line">    </div><div class="line">    if (y == SCREEN_HEIGHT) &#123;</div><div class="line">        _constraintBackView.constant = 0;</div><div class="line">        </div><div class="line">    &#125; else&#123;</div><div class="line">        _constraintBackView.constant = 100;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    [UIView animateWithDuration:0.25 animations:^&#123;</div><div class="line">        [self.view layoutIfNeeded];</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="判断一个控件是否真正显示在主窗口"><a href="#判断一个控件是否真正显示在主窗口" class="headerlink" title="判断一个控件是否真正显示在主窗口"></a>判断一个控件是否真正显示在主窗口</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> - (BOOL)isShowingOnKeyWindow&#123;</div><div class="line">    //主窗口</div><div class="line">    UIWindow *keyWindow = [UIApplication sharedApplication].keyWindow;</div><div class="line">    </div><div class="line">    //以主窗口左上角为坐标原点，计算self的矩形框</div><div class="line">    CGRect newFrame = [keyWindow convertRect:self.frame fromView:self.superview];</div><div class="line">    CGRect winBounds = keyWindow.bounds;</div><div class="line">    </div><div class="line">    //主窗口的bounds和self的矩形框 是否有重叠</div><div class="line">    BOOL intersects = CGRectIntersectsRect(newFrame, winBounds);</div><div class="line">    </div><div class="line">    return !self.isHidden &amp;&amp; self.alpha&gt;0.01 &amp;&amp; self.window == keyWindow &amp;&amp; intersects;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h4><ul>
<li>结构复杂的控件多采用自定义方式</li>
<li>添加约束时要注意，如果是可变的约束，要固定一段和高度，或者有些父控件根据子控件的内容改变大小</li>
<li>监听键盘的改变最好通过改变约束来调整控件</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/23/swift 中Array的使用方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lwg123">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lwg的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/23/swift 中Array的使用方式/" itemprop="url">swift中Array的使用方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-23T09:16:00+08:00">
                2017-06-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-尽量避免使用下标"><a href="#1-尽量避免使用下标" class="headerlink" title="1.尽量避免使用下标"></a>1.尽量避免使用下标</h2><p>对于array[index]这样的访问，甚至都没有使用optional来保护越界的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let a = [1, 2, 3]  </div><div class="line">type(of: a[1]) // Int.type</div></pre></td></tr></table></figure>
<p>a[1]的类型是Int，而不是Optional<int>，这说明什么呢？你必须小心翼翼的使用index来访问Array中的元素，一旦index的值不正确，你就需要承担运行崩溃的严重后果.</int></p>
<p>当我们想访问数组中的每一个元素时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a.forEach &#123; print($0) &#125;</div><div class="line">// or</div><div class="line">for value in a &#123;&#125;</div></pre></td></tr></table></figure>
<p>当我们要获得数组中每一个元素的索引和值时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">for(index, value) in a.enumerated()&#123;&#125;</div></pre></td></tr></table></figure>
<p>当我们要查找数组中元素的位置时（例如，查找等于1的元素的索引）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.index &#123; $0 == 1 &#125;</div></pre></td></tr></table></figure>
<p>index会返回一个Optional<int>，当要查找的元素存在时，就返回该元素的索引，否则，就返回nil</int></p>
<p>当我们要过滤数组中的某些元素时（例如，去掉所有偶数）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.filter &#123; $0 % 2 == 0 &#125;</div></pre></td></tr></table></figure>
<p>访问数组中第一个和最后一个元素的first和last属性，当Array为空时，它们的值都是nil</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a.first // 1</div><div class="line">a.last  // 3</div><div class="line">type(of: a.first) // Optional&lt;Int&gt;.Type</div></pre></td></tr></table></figure>
<p>Array末尾删除元素。Swift为这个动作提供了两个API:      </p>
<ul>
<li>removeLast，你需要自行确保数组中有元素，否则会引发运行时错误；</li>
<li>popLast，如果数组为空，会返回nil；</li>
</ul>
<h2 id="2-通过closure参数化对数组元素的变形操作"><a href="#2-通过closure参数化对数组元素的变形操作" class="headerlink" title="2.通过closure参数化对数组元素的变形操作"></a>2.通过closure参数化对数组元素的变形操作</h2><h4 id="从循环到map"><a href="#从循环到map" class="headerlink" title="从循环到map"></a>从循环到map</h4><p>Fibonacci序列：[0, 1, 1, 2, 3, 5]。如果我们要计算每个元素的平方，怎么办呢？<br>除了使用for循环，看看下面的解决方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// [0, 1, 1, 4, 9, 25]</div><div class="line">let constSquares = fibonacci.map &#123; $0 * $0 &#125;</div></pre></td></tr></table></figure>
<p>它比for循环更具表现力，并且也能把我们期望的结果定义成常量</p>
<p>通过extension很简单的自己来实现map:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">extension Array &#123;</div><div class="line">    func myMap&lt;T&gt;(_ transform: (Element) -&gt; T) -&gt; [T] &#123;</div><div class="line">        var tmp: [T] = []</div><div class="line">        tmp.reserveCapacity(count)</div><div class="line"></div><div class="line">        for value in self &#123;</div><div class="line">            tmp.append(transform(value))</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return tmp</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// [0, 1, 1, 4, 9, 25]</div><div class="line">let constSequence1 = fibonacci.myMap &#123; $0 * $0 &#125;</div></pre></td></tr></table></figure>
<h3 id="参数化数组元素的执行动作"><a href="#参数化数组元素的执行动作" class="headerlink" title="参数化数组元素的执行动作"></a>参数化数组元素的执行动作</h3><p>swift中一些常见的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fibonacci.min() // 0</div><div class="line">fibonacci.max() // 5</div></pre></td></tr></table></figure>
<p>首先，使用min和max很安全，因为当数组为空时，这两个方法将返回nil</p>
<p>其次，过滤出满足特定条件的元素，我们只要通过参数指定筛选规则就好了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fibonacci.filter &#123; $0 % 2 == 0 &#125;</div></pre></td></tr></table></figure>
<p>第三，比较数组相等或以特定元素开始。对这类操作，我们需要提供两个内容，一个是要比较的数组，另一个则是比较的规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// false</div><div class="line">fibonacci.elementsEqual([0, 1, 1], by: &#123; $0 == $1 &#125;)</div><div class="line">// true</div><div class="line">fibonacci.starts(with: [0, 1, 1], by: &#123; $0 == $1 &#125;)</div></pre></td></tr></table></figure>
<p>第四，最原始的for循环的替代品:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fibonacci.forEach &#123; print($0) &#125;</div></pre></td></tr></table></figure>
<p>要注意它和map的一个重要区别：forEach并不处理closure参数的返回值。因此它只适合用来对数组中的元素进行一些操作，而不能用来产生返回结果</p>
<p>第五、对数组进行排序，这时，我们需要通过参数指定的是排序规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// [0, 1, 1, 2, 3, 5]</div><div class="line">fibonacci.sorted()</div><div class="line">// [5, 3, 2, 1, 1, 0]</div><div class="line">fibonacci.sorted(by: &gt;) (&gt;号代表 $0 &gt; $1)</div><div class="line"></div><div class="line">let pivot = fibonacci.partition(by: &#123; $0 &lt; 1 &#125;)</div><div class="line">fibonacci[0 ..&lt; pivot] // [1，1，2, 3, 5]</div><div class="line">fibonacci[pivot ..&lt; fibonacci.endIndex] // [0]</div></pre></td></tr></table></figure>
<p>其中，sorted(by:)的用法是很直接的，它默认采用升序排列。同时，也允许我们通过by自定义排序规则</p>
<p>而partition(by:)则会先对传递给它的数组进行重排，然后根据指定的条件在重排的结果中返回一个分界点位置。这个分界点分开的两部分中，前半部分的元素都不满足指定条件；后半部分都满足指定条件。而后，我们就可以使用range operator来访问这两个区间形成的Array对象</p>
<p>第六，是把数组的所有内容，“合并”成某种形式的值，对这类操作，我们需要指定的，是合并前的初始值，以及“合并”的规则.<br>例如，我们计算fibnacci中所有元素的和</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fibonacci.reduce(0, +) // 12</div></pre></td></tr></table></figure>
<p>通过这些例子，你应该能感受到了，这些通过各种形式封装了遍历动作的方法，它们之中的任何一个，都比直接通过for循环实现具有更强的表现力。这些API，开始让我们的代码从面向机器的，转变成面向业务需求的.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/15/TCP连接与关闭及HTTP GCD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lwg123">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lwg的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/15/TCP连接与关闭及HTTP GCD/" itemprop="url">TCP正常建立与关闭详情</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-15T14:28:23+08:00">
                2017-06-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://oqfs0y2cu.bkt.clouddn.com/17-6-15/57541218.jpg" alt="image"></p>
<p>####建立连接<br>TCP协议提供可靠的面向连接服务，采用三次握手建立连接。<br>第一次握手：建立连接时，客户端发送SYN包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；<br>第二次握手：服务器收到SYN包，向客户端返回ACK（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RCVD状态；<br>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。<br>完成三次握手，客户端与服务器开始传送数据，也就是ESTABLISHED状态。</p>
<h4 id="终止连接"><a href="#终止连接" class="headerlink" title="终止连接"></a>终止连接</h4><p>采用四次挥手断开双向连接。<br>（1） TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。<br>（2） 服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。<br>（3） 服务器关闭客户端的连接，发送一个FIN给客户端。<br>（4） 客户端发回ACK报文确认，并将确认序号设置为收到序号加1。</p>
<h3 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h3><p><img src="http://oqfs0y2cu.bkt.clouddn.com/17-6-15/68230845.jpg" alt=""></p>
<h3 id="通过输入流方式提供请求体，无需将整个体加载到内存中"><a href="#通过输入流方式提供请求体，无需将整个体加载到内存中" class="headerlink" title="通过输入流方式提供请求体，无需将整个体加载到内存中"></a>通过输入流方式提供请求体，无需将整个体加载到内存中</h3><p>有两种方式可以向NSURLRequest提供HTTP体，如果发送如照片或者视频等大量内容，使用输入流是最佳选择</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let url = URL(string: &quot;123&quot;)</div><div class="line">var request: URLRequest = URLRequest(url: url!)</div><div class="line">request.httpBody = &quot;post bpdy&quot;.data(using: String.Encoding.utf8)</div><div class="line">request.httpMethod = &quot;POST&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let url = URL(string: &quot;123&quot;)</div><div class="line">var request: URLRequest = URLRequest(url: url!)</div><div class="line">let instream: InputStream = InputStream(fileAtPath: &quot;&quot;)!</div><div class="line">request.httpBodyStream = instream</div><div class="line">request.httpMethod = &quot;POST&quot;</div></pre></td></tr></table></figure>
<h3 id="GCD详情"><a href="#GCD详情" class="headerlink" title="GCD详情"></a>GCD详情</h3><p><img src="http://oqfs0y2cu.bkt.clouddn.com/17-6-15/19956836.jpg" alt=""></p>
<p><img src="http://oqfs0y2cu.bkt.clouddn.com/17-6-15/41332550.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; </div><div class="line">// 执行耗时的异步操作...dispatch_async(dispatch_get_main_queue(), ^&#123; </div><div class="line">// 回到主线，程执行UI刷新操作  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="分别异步执行两个耗时操作，等两个操作都执行完毕后在回到主线程执行操作，使用队列组（dispatch-group-t）快速，高效实现上述需求"><a href="#分别异步执行两个耗时操作，等两个操作都执行完毕后在回到主线程执行操作，使用队列组（dispatch-group-t）快速，高效实现上述需求" class="headerlink" title="分别异步执行两个耗时操作，等两个操作都执行完毕后在回到主线程执行操作，使用队列组（dispatch_group_t）快速，高效实现上述需求"></a>分别异步执行两个耗时操作，等两个操作都执行完毕后在回到主线程执行操作，使用队列组（dispatch_group_t）快速，高效实现上述需求</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> dispatch_group_t group = dispatch_group_create(); // 队列组</div><div class="line">    dispatch_queue_t queue = dispatch_get_global_queue(0, 0); //全局并发队列</div><div class="line">    dispatch_group_async(group, queue, ^&#123;</div><div class="line">        // 异步执行操作1</div><div class="line">        // longTime1</div><div class="line">    &#125;);</div><div class="line">    dispatch_group_async(group, queue, ^&#123;</div><div class="line">        // 异步执行操作2</div><div class="line">        // longTime2</div><div class="line">    &#125;);</div><div class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">       // 在主线程刷新数据</div><div class="line">        // reloadData</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">// 创建串行队列</div><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;serial&quot;, DISPATCH_QUEUE_SERIAL);</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/10/网络编程记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lwg123">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lwg的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/10/网络编程记录/" itemprop="url">Cookies 和 Session的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-10T13:50:00+08:00">
                2017-06-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-Cookies-和-Session的区别"><a href="#1-Cookies-和-Session的区别" class="headerlink" title="1.Cookies 和 Session的区别"></a>1.Cookies 和 Session的区别</h3><p>1.cookie 是一种发送到客户浏览器的文本串句柄，并保存在客户机硬盘上，可以用来在某个WEB站点会话间持久的保持数据。<br>2.session其实指的就是访问者从到达某个特定主页到离开为止的那段时间。 Session其实是利用Cookie进行信息处理的，当用户首先进行了请求后，服务端就在用户浏览器上创建了一个Cookie，当这个Session结束时，其实就是意味着这个Cookie就过期了。<br>注：为这个用户创建的Cookie的名称是aspsessionid。这个Cookie的唯一目的就是为每一个用户提供不同的身份认证。<br>3.cookie和session的共同之处在于：cookie和session都是用来跟踪浏览器用户身份的会话方式。<br>4.cookie 和session的区别是：cookie数据保存在客户端，session数据保存在服务器端。<br>5.两个都可以用来存私密的东西，同样也都有有效期的说法,区别在于session是放在服务器上的，过期与否取决于服务期的设定，cookie是存在客户端的，过去与否可以在cookie生成的时候设置进去。  </p>
<p><a href="https://my.oschina.net/kevinair/blog/192829" target="_blank" rel="external">深入理解 Session 与 Cookie</a></p>
<h3 id="2-如何操纵HTTP请求头与响应头"><a href="#2-如何操纵HTTP请求头与响应头" class="headerlink" title="2.如何操纵HTTP请求头与响应头"></a>2.如何操纵HTTP请求头与响应头</h3><p><strong>1.添加请求头</strong><br>当代码需要修改请求头时，需要创建<em>NSMutableURLRequest</em> 对象，NSMutableURLRequest类提供了两种添加方式，一种是直接替换全部请求头，一种是一次一个头添加；<br>setAllHTTPHeaderFields：方式一次调用替换所有的请求头<br>还可以将头逐个添加到请求中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSMutableURLRequest *req = [NSMutableURLRequest requestWithURL:rul];     </div><div class="line">[req addValue:@&quot;en&quot; forHTTPHeaderField:@&quot;Content-Language&quot;];</div><div class="line">[req addValue:@&quot;da&quot; forHTTPHeaderField:@&quot;Content-Language&quot;];</div></pre></td></tr></table></figure>
<p>如果相同的头名被添加多次，那么头的值就是多个值的拼接并使用逗号分隔。上述实例中，最后生成的头如下所示：<br>Content-Language：en,da</p>
<p><strong>2.删除请求头</strong><br>最好的方式是使用空值覆写默认值</p>
<p><strong>3.查看响应头</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">NSURLRequest *request = </div><div class="line">       [NSURLRequest requestWithURL:url </div><div class="line">                        cachePolicy:NSURLRequestReloadIgnoringLocalAndRemoteCacheData </div><div class="line">                    timeoutInterval:30.0];</div><div class="line">    </div><div class="line">    // Send the request and wait for a response</div><div class="line">    NSHTTPURLResponse   *response;</div><div class="line">    NSError             *error;</div><div class="line">    NSData *data = [NSURLConnection sendSynchronousRequest:request </div><div class="line">                                         returningResponse:&amp;response </div><div class="line">                                                     error:&amp;error];</div><div class="line">                                                     </div><div class="line"> // check for an error</div><div class="line">    if (error != nil) &#123;</div><div class="line">        NSLog(@&quot;Error on load = %@&quot;, [error localizedDescription]);</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // check the HTTP status</div><div class="line">    if ([response isKindOfClass:[NSHTTPURLResponse class]]) &#123;</div><div class="line">        NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)response;</div><div class="line">        if (httpResponse.statusCode != 200) &#123;</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">     	NSDictionary *headers = [httpResponse allHeaderFields];</div><div class="line">        NSLog(@&quot;Headers: %@&quot;, headers);</div><div class="line">        // 获取响应的MIME类型</div><div class="line">        NSString *contentType = [headers objectForKey:@&quot;Content-Type&quot;];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>4.主要的请求头</strong><br>Accept头、Authorization头、User-Agent头</p>
<h2 id="负载数据格式简介"><a href="#负载数据格式简介" class="headerlink" title="负载数据格式简介"></a>负载数据格式简介</h2><h3 id="1-XML-2、JSON-3、文本（HTML）"><a href="#1-XML-2、JSON-3、文本（HTML）" class="headerlink" title="1.XML 2、JSON 3、文本（HTML）"></a>1.XML 2、JSON 3、文本（HTML）</h3><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="ios应用中的网络错误源"><a href="#ios应用中的网络错误源" class="headerlink" title="ios应用中的网络错误源"></a>ios应用中的网络错误源</h3><h3 id="检测网络的可达性"><a href="#检测网络的可达性" class="headerlink" title="检测网络的可达性"></a>检测网络的可达性</h3><h3 id="错误处理的经验法则"><a href="#错误处理的经验法则" class="headerlink" title="错误处理的经验法则"></a>错误处理的经验法则</h3><h3 id="处理网络错误的设计模式"><a href="#处理网络错误的设计模式" class="headerlink" title="处理网络错误的设计模式"></a>处理网络错误的设计模式</h3><h4 id="操作系统错误"><a href="#操作系统错误" class="headerlink" title="操作系统错误"></a>操作系统错误</h4><ul>
<li>没有网络</li>
<li>无法路由到目标主机</li>
<li>没有应用监听目标端口</li>
<li>无法解析目标主机名<br>使用Reachability来检测网络情况，是否可用</li>
</ul>
<h4 id="HTTP错误"><a href="#HTTP错误" class="headerlink" title="HTTP错误"></a>HTTP错误</h4><p><em>一共有五类http错误</em></p>
<ul>
<li>信息性质的100级别</li>
<li>成功的200级别</li>
<li>重定向需要的300级别</li>
<li>客户端错误400级别</li>
<li>下游错误500级别<br>如果请求的url不是HTTP请求，需要验证响应对象是否是NSHTTPURLRespose对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if ([response isKinddOfClass:[NSHTTPURLResponse Class]]) &#123;</div><div class="line">        </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="应用错误"><a href="#应用错误" class="headerlink" title="应用错误"></a>应用错误</h3><p>这些错误是由运行在服务层之上的业务逻辑和应用造成的，并没有针对这些错误的标准或是原因的集合。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/09/网络请求缓存策略详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lwg123">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lwg的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/09/网络请求缓存策略详解/" itemprop="url">缓存NSURLCache详解和使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-09T14:53:07+08:00">
                2017-06-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>###1.参考此篇<a href="http://www.cnblogs.com/cbw1987/p/5910624.html" target="_blank" rel="external">详细博客</a>地址</p>
<p>###2.NSURLRequestCachePolicy的定义如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, NSURLRequestCachePolicy)</div><div class="line">&#123;</div><div class="line">    NSURLRequestUseProtocolCachePolicy = 0,</div><div class="line"></div><div class="line">    NSURLRequestReloadIgnoringLocalCacheData = 1,</div><div class="line">    NSURLRequestReloadIgnoringLocalAndRemoteCacheData = 4, // Unimplemented</div><div class="line">    NSURLRequestReloadIgnoringCacheData = NSURLRequestReloadIgnoringLocalCacheData,</div><div class="line"></div><div class="line">    NSURLRequestReturnCacheDataElseLoad = 2,</div><div class="line">    NSURLRequestReturnCacheDataDontLoad = 3,</div><div class="line"></div><div class="line">    NSURLRequestReloadRevalidatingCacheData = 5, // Unimplemented</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<ul>
<li>NSURLRequestUseProtocolCachePolicy<br>默认的缓存策略，其行为是由协议指定的针对该协议最好的实现方式</li>
<li>NSURLRequestReloadIgnoringCacheData<br>从服务端加载数据，完全忽略缓存</li>
<li>NSURLRequestReturnCacheDataElseLoad<br>使用缓存数据，忽略其过期时间；只有在没有缓存版本的时候才从源端加载数据</li>
<li>NSURLRequestReturnCacheDataDontLoad<br>只使用cache数据，如果不存在cache，请求失败；用于没有建立网络连接离线模式    </li>
</ul>
<h3 id="NSURLRequestUseProtocolCachePolicy实现机制"><a href="#NSURLRequestUseProtocolCachePolicy实现机制" class="headerlink" title="NSURLRequestUseProtocolCachePolicy实现机制"></a>NSURLRequestUseProtocolCachePolicy实现机制</h3><p><img src="http://oqfs0y2cu.bkt.clouddn.com/17-6-9/65529382.jpg" alt=""><br>由图中可以看出，简单流程如下：</p>
<p>1.如果请求的缓存响应不存在，则URL加载系统直接从源端加载数据；</p>
<p>2.否则，如果缓存响应中没有明确表示每次请求必须重新验证，则如果不是响应的缓存过期了，则URL加载系统会返回缓存数据</p>
<p>3.如果缓存的响应过期或者需要重新验证，URL加载系统发送HEAD请求到源端，查看资源是否发生了变化。如果变化了，则URL加载系统取出从始发源的数据。否则，它返回缓存的响应</p>
<h3 id="http协议详解-超详细"><a href="#http协议详解-超详细" class="headerlink" title="http协议详解(超详细)"></a><a href="http://www.jb51.net/article/28096.htm" target="_blank" rel="external">http协议详解(超详细)</a></h3><h3 id="网络传输协议（http协议"><a href="#网络传输协议（http协议" class="headerlink" title="网络传输协议（http协议)"></a><a href="http://www.jb51.net/article/97688.htm" target="_blank" rel="external">网络传输协议（http协议)</a></h3><p>Transfer-Encoding简介<br>transfer-eccoding所描述的是消息请求(request)和响应(response)所附带的实体对象(entity)的传输形式，规范定义格式如下：<br>举个例子：Transfer-Encoding: chunked<br>transfer-encoding的可选值有：chunked,identity，从字面意义可以理解，前者指把要发送传输的数据切割成一系列的块数据传输，后者指传输时不做任何处理，自身的本质数据形式传输。举个例子，如果我们要传输一本“红楼梦”小说到服务器，chunked方式就会先把这本小说分成一章一章的，然后逐个章节上传，而identity方式则是从小说的第一个字按顺序传输到最后一个字结束。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/06/社交分享/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lwg123">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lwg的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/06/社交分享/" itemprop="url">社交分享</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-06T14:50:47+08:00">
                2017-06-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-系统自带社交分享"><a href="#1-系统自带社交分享" class="headerlink" title="1.系统自带社交分享"></a>1.系统自带社交分享</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// 1. 判断用户是否有绑定账号密码(平台)</div><div class="line">       if SLComposeViewController.isAvailableForServiceType(SLServiceTypeSinaWeibo)</div><div class="line">       &#123;</div><div class="line">           // 2. 弹出一个分享窗口, 让用户开始输入内容</div><div class="line">           let vc = SLComposeViewController(forServiceType: SLServiceTypeSinaWeibo)</div><div class="line">           </div><div class="line">           // 2.1 设置默认分享的内容</div><div class="line">           vc.setInitialText(&quot;感谢小伙伴的支援&quot;)</div><div class="line">           vc.addImage(UIImage(named: &quot;zheyangdewangzi.jpg&quot;))</div><div class="line">           vc.addURL(NSURL(string: &quot;http://www.520it.com&quot;))</div><div class="line">           </div><div class="line">           // 2.2 监听分享状态</div><div class="line">           vc.completionHandler = &#123;</div><div class="line">               (result: SLComposeViewControllerResult) -&gt; Void</div><div class="line">               in</div><div class="line">               if result == .Cancelled &#123;</div><div class="line">                   print(&quot;取消&quot;)</div><div class="line">               &#125;else &#123;</div><div class="line">                   print(&quot;分享完成&quot;)</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           </div><div class="line">           </div><div class="line">           presentViewController(vc, animated: true, completion: nil)</div><div class="line">       &#125;else &#123;</div><div class="line">           print(&quot;请输入对应的账号密码&quot;)</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="lwg123" />
          <p class="site-author-name" itemprop="name">lwg123</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lwg123</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
